RAG-CLI ARCHITECTURE ANALYSIS REPORT
====================================

CRITICAL FINDINGS (7 Major Issues)
==================================

1. BIDIRECTIONAL DEPENDENCIES
   Problem: Monitoring imports core.config (upward) while Core imports monitoring (downward)
   File: monitoring/logger.py imports from core/config.py
   File: core/retrieval_pipeline.py imports from monitoring/*
   Impact: Circular dependency risk, prevents independent testing
   
2. PLUGIN-CORE TIGHT COUPLING  
   Problem: Plugin directly imports core implementations, not interfaces
   File: plugin/mcp/unified_server.py directly imports:
      - core.vector_store
      - core.embeddings
      - core.retrieval_pipeline
      - core.claude_integration
   Impact: Plugin breaks if core signatures change
   
3. MONOLITHIC RETRIEVAL PIPELINE
   Problem: Single file has 9+ external dependencies
   File: core/retrieval_pipeline.py imports from:
      - core.embeddings
      - core.vector_store
      - core.document_processor
      - core.online_retriever
      - core.duplicate_detector
      - core.semantic_cache
      - core.hyde
      - core.query_classifier
      - integrations.tavily_connector
   Impact: Cannot test retrieval without loading all modules
   
4. PATH RESOLUTION INCONSISTENCY
   Problem: 4 different path resolution strategies
   Locations:
      - core/config.py: parents[2]
      - session-start.py: parents[3]
      - unified_server.py: parents[3]
      - path_utils.py: custom implementation
   Impact: Plugin fails if run from wrong directory
   
5. SINGLETON PATTERN PREVENTS TESTING
   Problem: Global singletons block unit testing
   Examples:
      - get_config() global singleton
      - get_vector_store() global singleton
      - get_embedding_generator() global singleton
   Impact: Cannot isolate components, test pollution
   
6. NO MOCK IMPLEMENTATIONS
   Problem: No test doubles available
   Missing:
      - MockVectorStore
      - MockEmbeddings
      - MockLogger
      - MockRetriever
   Impact: Tests slow/brittle, must use real implementations
   
7. SERVICE BOUNDARY VIOLATIONS
   Problem: Multiple concerns mixed in retrieval_pipeline.py:
      - Vector search (core)
      - Query classification (agent concern)
      - Query enhancement (separate service)
      - Query decomposition (agent concern)
      - Duplicate detection (indexing concern)
      - Online retrieval (separate service)
   Impact: Hard to maintain, test, extend

ARCHITECTURE LAYER ISSUES
========================

Current Structure:
Plugin (11 hooks, 2 skills, MCP)
  |
Core (50+ modules, monolithic retrieval)
  |
Monitoring (logging, metrics, service mgmt)
  |
Integrations & Agents

Problems:
- Plugin depends on Core implementation (should be abstract)
- Core depends on Monitoring (inverted, should be abstract)
- Monitoring manages services (not its responsibility)
- Integrations optional imports hide dependencies

INTERFACE SEGREGATION PROBLEMS
==============================

1. Config Object Has 13 Concerns:
   - document_processing config
   - embeddings config
   - vector_store config
   - retrieval config
   - online_docs config
   - claude config
   - monitoring config
   - plugin config
   - testing config
   - performance config
   - development config
   - security config
   - system/mode (undocumented)
   
   Issue: Every component gets ALL config
   Should be: Component gets only its interface

2. Logger Not Interfaced:
   - No ILogger abstraction
   - Global singleton blocks testing
   - Cannot mock for testing
   - Mixed diagnostics and metrics

3. Vector Store Interface Incomplete:
   - search() return type undocumented
   - add() metadata format unclear
   - No explicit error contracts
   - Cannot rely on interface

TESTING GAPS
============

Missing:
- No mock implementations
- No test fixtures
- No builder patterns
- No integration helpers
- No performance benchmarks

Blockers:
- Global config singleton
- Global vector store singleton
- Hard-coded instantiation
- No dependency injection
- No test config

Current Coverage:
- test_foundation.py (minimal)
- test_core.py (minimal)
- test_integration.py (minimal)

SERVICE BOUNDARY ISSUES
=======================

Retrieval Pipeline Should Be Separated:
1. Vector search service
2. Keyword search service  
3. Ranking service
4. Query service (classify/enhance)
5. Agent service (decompose)
6. Caching infrastructure
7. Data quality (duplicates)
8. Integration (online search)

Currently: ALL mixed in one 500+ line module

Monitoring Mixed Concerns:
1. Logging (legitimate)
2. Metrics (legitimate)
3. TCP server (infrastructure)
4. Service lifecycle (orchestration, not monitoring)
5. Path management (deployment)
6. PID file management (DevOps)

Currently: ALL mixed in monitoring layer

DATA FLOW BOTTLENECKS
====================

Query to Response:
Query → Classify → Enhance → Retrieve → Generate → Response
Issues:
- Sequential where parallel possible
- Online search not parallelized with API call
- Embedding batch size static (should be dynamic)
- Vector search single-threaded

Document Indexing:
Docs → Process → Embed → Store → Save
Issues:
- Vector insertion sequential (should batch)
- Metadata I/O blocking (should async)
- Index optimization not parallelized
- No dynamic batching for GPU

CONFIGURATION MANAGEMENT ISSUES
================================

Path Resolution Inconsistent:
Location 1: core/config.py - parents[2]
Location 2: session-start.py - parents[3]
Location 3: unified_server.py - parents[3]
Location 4: path_utils.py - custom

Result: 4 different methods = unreliable

Validation Scattered:
- Pydantic validators in models
- Custom validators in components
- No central validation

Access Patterns Inconsistent:
Pattern 1: config.document_processing.chunk_size
Pattern 2: from constants import CHUNK_SIZE_TOKENS
Result: Which value is used?

QUICK WINS (Implement First)
============================

1. Centralize Path Resolution (2 hours)
   - PathResolver class
   - Single source of truth

2. Create Constants Module (2 hours)
   - Centralize magic numbers
   - Reduce duplication

3. Add Logging Interface (3 hours)
   - ILogger abstract class
   - Decouple implementation

4. Create Test Mocks (4 hours)
   - MockVectorStore
   - MockEmbeddings
   - MockLogger

5. Add Docstrings (4 hours)
   - Module purposes
   - Method contracts

Total: ~15 hours for major improvement

HIGH PRIORITY REFACTORING
=========================

1. Create Abstract Interfaces
   - IVectorStore
   - IEmbeddings
   - IRetriever
   - ILogger
   - IQueryClassifier

2. Invert Monitoring Dependency
   - Create logging interface
   - Move implementation to monitoring
   - Core depends on interface

3. Replace Singletons with DI
   - DIContainer (already exists)
   - Register all services
   - Inject dependencies

4. Break Retrieval Pipeline
   - Create stage interface
   - Separate concerns (search, rank, filter)
   - Orchestrate stages

5. Centralize Path Resolution
   - PathResolver service
   - Update all modules

ESTIMATED EFFORT
================

Quick Wins: 1-2 weeks
Phase 1 (Foundations): 2-3 weeks
Phase 2 (Layer Separation): 2 weeks  
Phase 3 (Testing): 1-2 weeks
Phase 4 (Documentation): 1 week

Total: 4-6 weeks for full refactoring

SUMMARY
=======

Strengths:
- Extensive feature set
- Comprehensive config system
- Multiple integration points
- Monitoring infrastructure

Weaknesses:
- Bidirectional dependencies
- Tight coupling between layers
- No abstraction boundaries
- Singleton pattern prevents testing
- Service boundaries unclear
- Inconsistent path resolution
- No mock implementations

To Improve:
1. Follow dependency inversion principle
2. Create clear service boundaries
3. Replace singletons with DI
4. Create comprehensive mocks
5. Centralize configuration access

